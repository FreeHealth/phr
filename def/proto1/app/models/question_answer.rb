class QuestionAnswer < ActiveRecord::Base
  belongs_to :user

  # The qtype value for a user-defined question.
  USER_QUESTION = 0

  # The qtype value for a fixed question
  FIXED_QUESTION = 1
  
  # questions and answers cannot be blank  
  validates_presence_of :question
  validates_presence_of :answer
  
  # Both fixed and self-defined questions have to be unique
  validates_uniqueness_of :question, :scope =>[:user_id, :qtype],
    :message => User.self_questions_must_not_match_msg,
    :if => Proc.new {|user| user.qtype == QuestionAnswer::USER_QUESTION }
  validates_uniqueness_of :question, :scope =>[:user_id, :qtype],
    :message => User.predef_questions_must_not_match_msg,
    :if => Proc.new {|user| user.qtype == QuestionAnswer::FIXED_QUESTION }
  
  
  # This method encrypts the answer after changing it to uppercase for case
  # insensitive comparison.
  # Parameters:
  # * answer -raw string of the password.
  # * salt - the random string generated by create_new_salt(user)
  # Returns:  the encrypted answer
  def encrypted_answer(answer)
    ans_str = answer.strip
    # Add in a constant to make the hash harder to guess
    string_to_hash = ans_str.upcase + '8e26db' + self.user.salt
    return Digest::SHA256.hexdigest(string_to_hash)
  end


  # This method checks if answer is correct
  # Parameters:
  # * answer -raw string of the password.
  # * salt - the random string generated by create_new_salt(user)
  # Returns: true if answer correct, false otherwise
  def right_answer?(answer)
    return encrypted_answer(answer) == self.answer ? true : false
  end


  # This method sets hashed answer to a question
  # Parameters:
  # * answer -raw string of the password.
  # * salt - the random string generated by create_new_salt(user)
  # Returns: true if answer correct, false otherwise
  def answer=(ans)
    super encrypted_answer(ans)
  end

end
